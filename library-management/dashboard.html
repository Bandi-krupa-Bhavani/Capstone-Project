<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BOOKVERSE ‚Äî Dashboard</title>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Playfair+Display:wght@500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <link rel="stylesheet" href="css/dashboard.css" />
</head>
<body>
  <!-- Header (profile-style) -->
  <header>
    <div class="header-left">
      <div class="logo"><i class="fa-solid fa-book"></i><span style="margin-left:6px;">BookVerse</span></div>
      <div id="welcomeName">Welcome</div>
    </div>

    <div class="header-right">
      <div id="dateTime" aria-live="polite" title="Current date and time">
        <span id="dtText">‚Äî</span>
        <small>IST</small>
      </div>
    </div>
  </header>


  <!-- Toggle button (profile-like) -->
  <button class="toggle-btn" id="toggleBtn" aria-label="Toggle sidebar">‚ò∞</button>

  <!-- Sidebar -->
  <nav class="sidebar" id="sidebar" aria-label="Main navigation">
    <a href="dashboard.html" class="active"><i class="fa-solid fa-house"></i> Dashboard</a>
    <a href="library.html"><i class="fa-solid fa-book-open"></i> My Library</a>
    <a href="profile.html"><i class="fa-solid fa-user"></i> Profile</a>
    <a href="index.html"><i class="fa-solid fa-right-from-bracket"></i> Logout</a>
  </nav>

  <!-- Search below header -->
  <div class="search-wrap" id="searchWrap">
    <div class="search-container">
      <div class="search-box">
        <input id="searchInput" type="search" placeholder="Search books, authors, topics..." aria-label="Search books" autocomplete="off" />
        <i class="fa-solid fa-magnifying-glass"></i>
        <div id="searchResults" class="search-results" role="listbox" aria-label="Search results"></div>
      </div>
    </div>
  </div>

  <!-- Main content -->
  <main class="main" id="mainContent">
     <div class="dashboard-layout">
    <div class="left-container">
      <h2 class="section-title">üìö Explore Knowledge</h2>

      <section class="domain">
        <h3>Computer Science</h3>
        <div class="subgrid">
          <a class="subcard" href="cs-fund.html">
            <div class="icon-wrap"><i class="fa-solid fa-layer-group"></i></div>
            <div class="subcard-title">CS Fundamentals</div>
            <div class="subline">Core theory & concepts</div>
          </a>

          <a class="subcard" href="prog.html">
            <div class="icon-wrap"><i class="fa-solid fa-code"></i></div>
            <div class="subcard-title">Programming</div>
            <div class="subline">Hands-on coding</div>
          </a>

          <a class="subcard" href="adv-topics.html">
            <div class="icon-wrap"><i class="fa-solid fa-brain"></i></div>
            <div class="subcard-title">Advanced Topics</div>
            <div class="subline">ML, Systems, Theory</div>
          </a>
        </div>
      </section>
        <!-- ===== Domain: Engineering example ===== -->
        <div class="domain" aria-labelledby="eng-title">
          <h3 id="eng-title">Engineering</h3>

          <div class="subgrid">
            <div class="subcard-wrapper">
              <a class="subcard" href="civil.html" aria-label="Civil Engineering">
                <div class="icon-wrap"><i class="fa-solid fa-building"></i></div>
                <span>Civil Engineering</span>
                <div class="subline">Structures, design & Construction</div>
              </a>
            </div>

            <div class="subcard-wrapper">
              <a class="subcard" href="electrical.html" aria-label="Electrical Engineering">
                <div class="icon-wrap"><i class="fa-solid fa-plug"></i></div>
                <span>Electrical Engineering</span>
                <div class="subline">Circuits & power</div>
              </a>
            </div>

            <div class="subcard-wrapper">
              <a class="subcard" href="mechanical.html" aria-label="Mechanical Engineering">
                <div class="icon-wrap"><i class="fa-solid fa-gears"></i></div>
                <span>Mechanical Engineering</span>
                <div class="subline">Dynamics </div>
              </a>
            </div>
          </div>
        </div>

        <!-- ===== Domain: Others ===== -->
        <div class="domain" aria-labelledby="other-title">
          <h3 id="other-title">Others</h3>

          <div class="subgrid">
            <div class="subcard-wrapper">
              <a class="subcard" href="environment.html" aria-label="Environment">
                <div class="icon-wrap"><i class="fa-solid fa-leaf"></i></div>
                <span>Eco-Social</span>
                <div class="subline">Sustainability & ethics</div>
              </a>
            </div>

            <div class="subcard-wrapper">
              <a class="subcard" href="lifestyle.html" aria-label="Lifestyle">
                <div class="icon-wrap"><i class="fa-solid fa-heart"></i></div>
                <span>Lifestyle & Wellness</span>
                <div class="subline">Health & habits</div>
              </a>
            </div>

            <div class="subcard-wrapper">
              <a class="subcard" href="research-papers.html" aria-label="Research Papers">
                <div class="icon-wrap"><i class="fa-solid fa-file-lines"></i></div>
                <span>Research Papers</span>
                <div class="subline">Latest studies</div>
              </a>
            </div>
          </div>
        </div>
      <!-- add more domain sections here as needed -->
    </div>

     <!-- RIGHT SIDE ‚Äî NEW RECOMMENDATIONS SIDEBAR -->
    <aside class="right-recommend">
  <h3 id="recHeading">Recommendations</h3>
  <p id="recSub" style="margin:4px 0 14px; font-size:0.8rem; color:#3e2c20;">
    Start adding favourites to get personalised suggestions.
  </p>

  <div class="rec-carousel">
    <button class="rec-nav" id="recPrev" aria-label="Previous recommendation">‚Äπ</button>

    <div class="rec-card-large" id="recCard">
      <!-- JS will fill -->
      <p style="font-size:0.8rem; color:#3e2c20; margin:0;">
        No recommendations yet.
      </p>
    </div>

    <button class="rec-nav" id="recNext" aria-label="Next recommendation">‚Ä∫</button>
  </div>

  <div class="rec-dots" id="recDots">
    <!-- dots go here -->
  </div>
</aside>

    </div>
  </main>

<!-- POPUP -->
 <!-- POPUP: put this near end of body (before </body>) -->
<div id="welcomePopup" class="popup-overlay" aria-hidden="true" style="display:none;">
  <div class="popup-content" role="dialog" aria-modal="true" aria-label="Welcome popup">
    <button class="close-btn" id="popupCloseBtn" aria-label="Close popup">‚úñ</button>

    <div class="popup-inner">
      <img id="popupImage" src="" alt="Welcome image - books and reading" />
      <p class="popup-caption" id="popupCaption" aria-live="polite"></p>
    </div>
  </div>
</div>

  <!-- ---------- Scripts ---------- -->
<script src="books.js"></script>
<script type="module">
  import {
    doc,
    onSnapshot,
    getDoc,
    collection,
    query,
    orderBy,
    getDocs
  } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

  import { auth, db } from "./firebase-config.js";
  import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

  // ==== DOM refs ====
  const welcomeNameEl = document.getElementById('welcomeName');
  const dtText        = document.getElementById('dtText');
  const toggleBtn     = document.getElementById('toggleBtn');
  const sidebar       = document.getElementById('sidebar');
  const searchWrap    = document.getElementById('searchWrap');
  const mainEl        = document.getElementById('mainContent');

  // Recommendation carousel refs
  const recCardEl   = document.getElementById('recCard');
  const recDotsEl   = document.getElementById('recDots');
  const recPrevBtn  = document.getElementById('recPrev');
  const recNextBtn  = document.getElementById('recNext');

  let recBooksGlobal  = [];
  let recCurrentIndex = 0;
  let recSeedBook     = null;
  let favUnsub        = null;

  // Initial loading state
  if (recCardEl) {
    recCardEl.innerHTML = `
      <p style="font-size:0.8rem; color:#3e2c20; margin:0;">
        Loading recommendations‚Ä¶
      </p>
    `;
  }

  // =========================
  //  SIDEBAR TOGGLE
  // =========================
  toggleBtn.addEventListener('click', () => {
    sidebar.classList.toggle('active');
    searchWrap.classList.toggle('shift');
    mainEl.classList.toggle('shift');
    document.body.classList.toggle('sidebar-open');
  });

  document.addEventListener('click', (e) => {
    if (
      !sidebar.contains(e.target) &&
      !e.target.closest('.toggle-btn') &&
      sidebar.classList.contains('active') &&
      !e.target.closest('#toggleBtn')
    ) {
      sidebar.classList.remove('active');
      searchWrap.classList.remove('shift');
      mainEl.classList.remove('shift');
      document.body.classList.remove('sidebar-open');
    }
  });

  // =========================
  //  CLOCK
  // =========================
  function formatKolkata(dt) {
    try {
      return new Intl.DateTimeFormat('en-IN', {
        dateStyle: 'medium',
        timeStyle: 'short',
        timeZone: 'Asia/Kolkata'
      }).format(dt);
    } catch (e) {
      return dt.toLocaleString();
    }
  }

  function startClock() {
    function tick() {
      if (dtText) dtText.textContent = formatKolkata(new Date());
    }
    tick();
    setInterval(tick, 1000);
  }
  startClock();

  // =========================
  //  BOOKVERSE_DATA HELPERS
  // =========================
  function findBookInCatalogue(bookId) {
    const data = window.BOOKVERSE_DATA || {};
    for (const domainName in data) {
      const domain = data[domainName];
      for (const categoryName in domain) {
        const booksArr = domain[categoryName];
        const found = booksArr.find(b => b.id === bookId || b.bookId === bookId);
        if (found) {
          return {
            ...found,
            domain: domainName,
            category: categoryName
          };
        }
      }
    }
    return null;
  }

  function getAllBooksFromCatalogue() {
    const data = window.BOOKVERSE_DATA || {};
    const all = [];
    for (const domainName in data) {
      const domain = data[domainName];
      for (const categoryName in domain) {
        const booksArr = domain[categoryName];
        booksArr.forEach(b => {
          all.push({
            ...b,
            domain: domainName,
            category: categoryName
          });
        });
      }
    }
    return all;
  }

  function getTargetPageForBook(book) {
    if (!book) return "library.html";

    const d = book.domain;
    const c = book.category;

    if (d === "Computer Science") {
      if (c === "CS Fundamentals") return "cs-fund.html";
      if (c === "Programming")     return "prog.html";
      if (c === "Advanced Topics") return "adv-topics.html";
    }

    if (d === "Engineering") {
      if (c === "Civil Engineering")      return "civil.html";
      if (c === "Electrical Engineering") return "electrical.html";
      if (c === "Mechanical Engineering") return "mechanical.html";
    }

    if (d === "Others") {
      if (c === "Eco-Social")           return "environment.html";
      if (c === "Lifestyle & Wellness") return "lifestyle.html";
      if (c === "Research Papers")      return "research-papers.html";
    }

    return "library.html";
  }

  // =========================
  //  RULE-BASED SIMILAR BOOKS (FALLBACK)
  // =========================
  function getSimilarFromCatalogue(seedBook) {
    if (!seedBook) return [];

    const allBooks = getAllBooksFromCatalogue();
    const sameCategory = [];
    const sameDomain   = [];
    const others       = [];

    allBooks.forEach(book => {
      if (book.id === seedBook.id) return;

      if (book.domain === seedBook.domain && book.category === seedBook.category) {
        sameCategory.push(book);
      } else if (book.domain === seedBook.domain) {
        sameDomain.push(book);
      } else {
        others.push(book);
      }
    });

    function scoreAndSort(arr) {
      arr.forEach(book => {
        let score = 0;

        if (book.author && seedBook.author && book.author === seedBook.author) {
          score += 2;
        }

        if (Array.isArray(book.tags) && Array.isArray(seedBook.tags)) {
          const common = seedBook.tags.filter(t => book.tags.includes(t));
          score += common.length;
        }

        book._score = score;
      });

      arr.sort((a, b) => (b._score || 0) - (a._score || 0));
      return arr;
    }

    if (sameCategory.length) {
      return scoreAndSort(sameCategory);
    }

    if (sameDomain.length) {
      return scoreAndSort(sameDomain);
    }

    return scoreAndSort(others);
  }

  // =========================
  //  AI RECOMMENDER HELPERS
  // =========================

  function buildAIVocabulary() {
    const data = window.BOOKVERSE_DATA || {};
    const vocabSet = new Set();

    for (const domainName in data) {
      const domain = data[domainName];
      vocabSet.add(`domain:${domainName}`);

      for (const categoryName in domain) {
        const booksArr = domain[categoryName];
        vocabSet.add(`cat:${categoryName}`);

        booksArr.forEach(b => {
          if (Array.isArray(b.tags)) {
            b.tags.forEach(t => vocabSet.add(`tag:${String(t).toLowerCase()}`));
          }
        });
      }
    }

    return Array.from(vocabSet);
  }

  const AI_VOCAB = buildAIVocabulary();
  const AI_VOCAB_INDEX = AI_VOCAB.reduce((map, token, idx) => {
    map[token] = idx;
    return map;
  }, {});

  function vectorForBook(book) {
    const vec = new Array(AI_VOCAB.length).fill(0);
    if (!book) return vec;

    // domain
    if (book.domain) {
      const key = `domain:${book.domain}`;
      const idx = AI_VOCAB_INDEX[key];
      if (idx !== undefined) vec[idx] = 1;
    }

    // category
    if (book.category) {
      const key = `cat:${book.category}`;
      const idx = AI_VOCAB_INDEX[key];
      if (idx !== undefined) vec[idx] = 1;
    }

    // tags
    if (Array.isArray(book.tags)) {
      book.tags.forEach(t => {
        const key = `tag:${String(t).toLowerCase()}`;
        const idx = AI_VOCAB_INDEX[key];
        if (idx !== undefined) vec[idx] = 1;
      });
    }

    return vec;
  }

  function addVectors(a, b) {
    const res = new Array(a.length);
    for (let i = 0; i < a.length; i++) {
      res[i] = a[i] + b[i];
    }
    return res;
  }

  function scaleVector(vec, scalar) {
    return vec.map(v => v * scalar);
  }

  function cosineSimilarity(a, b) {
    let dot = 0, normA = 0, normB = 0;
    for (let i = 0; i < a.length; i++) {
      dot   += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }
    if (!normA || !normB) return 0;
    return dot / (Math.sqrt(normA) * Math.sqrt(normB));
  }

  function buildUserProfileFromFavDocs(favDocs) {
    if (!favDocs || !favDocs.length || !AI_VOCAB.length) return null;

    let sumVec = null;
    let count  = 0;

    favDocs.forEach(docSnap => {
      const favData = docSnap.data();
      const favId   = favData.bookId || favData.id || docSnap.id;

      const book = findBookInCatalogue(favId);
      if (!book) return; // skip if ID not in catalogue

      const vec = vectorForBook(book);
      if (!sumVec) {
        sumVec = vec;
      } else {
        sumVec = addVectors(sumVec, vec);
      }
      count += 1;
    });

    if (!sumVec || count === 0) return null;

    return scaleVector(sumVec, 1 / count); // average user profile
  }

  function getAIRecommendationsForUserProfile(userProfileVec, limit = 5) {
    if (!userProfileVec || !AI_VOCAB.length) return [];

    const allBooks = getAllBooksFromCatalogue();
    const scored = [];

    allBooks.forEach(book => {
      const vec = vectorForBook(book);
      const sim = cosineSimilarity(userProfileVec, vec);
      if (sim > 0) {
        scored.push({ book, score: sim });
      }
    });

    scored.sort((a, b) => b.score - a.score);

    return scored.slice(0, limit).map(x => x.book);
  }

  // =========================
  //  RECOMMENDATION CAROUSEL VIEW
  // =========================
  function updateRecCarouselView() {
    if (!recCardEl || !recDotsEl || !recPrevBtn || !recNextBtn) return;

    if (!recBooksGlobal || recBooksGlobal.length === 0) {
      recCardEl.innerHTML = `
        <p style="font-size:0.8rem; color:#3e2c20; margin:0;">
          No recommendations yet. Start adding favourites to see personalised suggestions.
        </p>
      `;
      recCardEl.onclick = null;
      recPrevBtn.classList.add('disabled');
      recNextBtn.classList.add('disabled');
      recDotsEl.innerHTML = '';
      return;
    }

    if (recCurrentIndex < 0) recCurrentIndex = 0;
    if (recCurrentIndex >= recBooksGlobal.length) {
      recCurrentIndex = recBooksGlobal.length - 1;
    }

    const book   = recBooksGlobal[recCurrentIndex];
    const imgSrc = book.cover || "css/assets/covers/default-book.png";

    recCardEl.innerHTML = `
      <div class="rec-cover">
        <img src="${imgSrc}" alt="${book.title || 'Book'}">
      </div>
      <div class="rec-text">
        <div class="rec-title">${book.title || 'Untitled Book'}</div>
        <div class="rec-author">${book.author || book.authors?.join(', ') || ''}</div>
        <div class="rec-meta">${book.category || ''}</div>
      </div>
    `;

    recCardEl.onclick = () => {
      const targetPage = getTargetPageForBook(book);
      const hash       = encodeURIComponent(book.title || book.id);
      window.location.href = `${targetPage}#${hash}`;
    };

    if (recBooksGlobal.length <= 1) {
      recPrevBtn.classList.add('disabled');
      recNextBtn.classList.add('disabled');
    } else {
      recPrevBtn.classList.toggle('disabled', recCurrentIndex === 0);
      recNextBtn.classList.toggle('disabled', recCurrentIndex === recBooksGlobal.length - 1);
    }

    recDotsEl.innerHTML = '';
    recBooksGlobal.forEach((_, idx) => {
      const dot = document.createElement('button');
      dot.className = 'rec-dot' + (idx === recCurrentIndex ? ' active' : '');
      dot.addEventListener('click', () => {
        recCurrentIndex = idx;
        updateRecCarouselView();
      });
      recDotsEl.appendChild(dot);
    });
  }

  if (recPrevBtn) {
    recPrevBtn.addEventListener('click', () => {
      if (recBooksGlobal.length <= 1) return;
      if (recCurrentIndex > 0) {
        recCurrentIndex -= 1;
        updateRecCarouselView();
      }
    });
  }

  if (recNextBtn) {
    recNextBtn.addEventListener('click', () => {
      if (recBooksGlobal.length <= 1) return;
      if (recCurrentIndex < recBooksGlobal.length - 1) {
        recCurrentIndex += 1;
        updateRecCarouselView();
      }
    });
  }

  // =========================
  //  RENDER "Because you liked X"
  // =========================
  function renderBecauseYouLiked(seedBook, recBooks) {
    const headingEl = document.getElementById("recHeading");
    const subEl     = document.getElementById("recSub");

    if (!headingEl || !subEl) return;

    recSeedBook     = seedBook || null;
    recBooksGlobal  = Array.isArray(recBooks) ? recBooks.slice(0, 5) : [];
    recCurrentIndex = 0;

    if (!seedBook) {
      headingEl.textContent = "Recommendations";
      subEl.textContent = "Start adding favourites to get personalised suggestions.";
      updateRecCarouselView();
      return;
    }

    headingEl.textContent = `Because you liked ${seedBook.title || "this book"}`;
    subEl.textContent = "AI-based recommendations using your favourites‚Äô domain, category & tags.";

    updateRecCarouselView();
  }

  // =========================
  //  ONE-SHOT LOAD (OLD USERS) ‚Äî AI FIRST
  // =========================
  async function oneShotLoadRecommendations(userId) {
    try {
      const favRef = collection(db, "users", userId, "favorites");
      const qFav   = query(favRef, orderBy("addedAt", "desc"));
      const snap   = await getDocs(qFav);

      console.log("[dash] oneShotLoadRecommendations size =", snap.size);

      if (snap.empty) {
        renderBecauseYouLiked(null, []);
        return;
      }

      const favDocs = snap.docs;

      // AI profile from ALL favourites
      const userProfileVec = buildUserProfileFromFavDocs(favDocs);

      // Use most recent favourite for heading text
      const latestDoc = favDocs[0];
      const favData   = latestDoc.data();
      const favId =
        favData.bookId ||
        favData.id     ||
        latestDoc.id;

      let seedBook = findBookInCatalogue(favId);
      if (!seedBook) {
        seedBook = { id: favId, ...favData };
      }

      let recs = [];

      if (userProfileVec) {
        recs = getAIRecommendationsForUserProfile(userProfileVec, 5)
          .filter(b => b.id !== seedBook.id);
      }

      // Fallback: old rule-based logic
      if (!recs.length) {
        recs = getSimilarFromCatalogue(seedBook);

        if (!recs.length) {
          const all = getAllBooksFromCatalogue();
          const sameDomain = all.filter(
            (b) => b.id !== seedBook.id &&
                   seedBook.domain &&
                   b.domain === seedBook.domain
          );

          if (sameDomain.length) {
            recs = sameDomain.slice(0, 3);
          } else {
            recs = all.filter(b => b.id !== seedBook.id).slice(0, 3);
          }
        }
      }

      renderBecauseYouLiked(seedBook, recs);
    } catch (e) {
      console.error("[dash] oneShotLoadRecommendations error:", e);
      renderBecauseYouLiked(null, []);
    }
  }

  // =========================
  //  FAVORITES SNAPSHOT (LIVE RECS) ‚Äî AI FIRST
  // =========================
  function setupFavoritesListener(userId, hasInitialUI = false) {
    if (favUnsub) {
      try { favUnsub(); } catch (e) {}
      favUnsub = null;
    }

    const favRef = collection(db, "users", userId, "favorites");
    const qFav   = query(favRef, orderBy("addedAt", "desc"));

    let isFirstSnapshot = true;

    favUnsub = onSnapshot(
      qFav,
      (snap) => {
        console.log("[dash] favorites snapshot size =", snap.size);

        if (snap.empty) {
          // first snapshot + already UI unte, clear cheyyakunda vadilesi
          if (isFirstSnapshot && hasInitialUI) {
            console.log("[dash] first empty snapshot, keeping existing UI");
            isFirstSnapshot = false;
            return;
          }

          renderBecauseYouLiked(null, []);
          isFirstSnapshot = false;
          return;
        }

        isFirstSnapshot = false;

        const favDocs = snap.docs;

        // 1Ô∏è‚É£ AI user profile from ALL favourites
        const userProfileVec = buildUserProfileFromFavDocs(favDocs);

        // 2Ô∏è‚É£ Most recent favourite as seed for heading
        const latestDoc  = favDocs[0];
        const favData    = latestDoc.data();
        const favId =
          favData.bookId ||
          favData.id     ||
          latestDoc.id;

        let seedBook = findBookInCatalogue(favId);
        if (!seedBook) {
          seedBook = { id: favId, ...favData };
        }

        let recs = [];

        // 3Ô∏è‚É£ First try AI-based recommendations
        if (userProfileVec) {
          recs = getAIRecommendationsForUserProfile(userProfileVec, 5)
            .filter(b => b.id !== seedBook.id);
        }

        // 4Ô∏è‚É£ Fallback to old rule-based logic if needed
        if (!recs.length) {
          recs = getSimilarFromCatalogue(seedBook);

          if (!recs.length) {
            const all = getAllBooksFromCatalogue();
            const sameDomain = all.filter(
              b => b.id !== seedBook.id &&
                   seedBook.domain &&
                   b.domain === seedBook.domain
            );
            if (sameDomain.length) {
              recs = sameDomain.slice(0, 3);
            } else {
              recs = all.filter(b => b.id !== seedBook.id).slice(0, 3);
            }
          }
        }

        renderBecauseYouLiked(seedBook, recs);
      },
      (err) => {
        console.error("[dash] favorites snapshot error:", err);
        renderBecauseYouLiked(null, []);
      }
    );
  }

  // =========================
  //  AUTH + WELCOME + POPUP + RECS
  // =========================
  onAuthStateChanged(auth, async (user) => {
    const cached = sessionStorage.getItem('fullname') || null;

    if (!user) {
      if (favUnsub) {
        try { favUnsub(); } catch (e) {}
        favUnsub = null;
      }
      welcomeNameEl.textContent = cached ? `Welcome! ${cached}` : 'Welcome';
      renderBecauseYouLiked(null, []);
      return;
    }

    // Popup
    const shouldShow = sessionStorage.getItem('showWelcomePopup');
    if (shouldShow === '1' && window.showWelcomePopup) {
      window.showWelcomePopup();
      sessionStorage.removeItem('showWelcomePopup');
    }

    // Name logic
    let resolvedName = user.displayName || cached || 'Welcome';
    welcomeNameEl.textContent = `Welcome! ${resolvedName}`;

    try {
      const editRef = doc(db, 'users', user.uid, 'editProfiles', 'profile');
      onSnapshot(
        editRef,
        (snap) => {
          if (snap.exists() && snap.data().fullname) {
            resolvedName = snap.data().fullname;
          }
          welcomeNameEl.textContent = `Welcome! ${resolvedName}`;
          sessionStorage.setItem('fullname', resolvedName);
          sessionStorage.setItem('fullnameUpdatedAt', Date.now());
        },
        async (err) => {
          console.warn('profile snapshot err', err);
          try {
            const fallback = await getDoc(editRef);
            if (fallback.exists() && fallback.data().fullname) {
              resolvedName = fallback.data().fullname;
            }
          } catch (e) {}
          welcomeNameEl.textContent = `Welcome, ${resolvedName}`;
        }
      );
    } catch (e) {
      console.warn('load profile err', e);
      welcomeNameEl.textContent = `Welcome, ${resolvedName}`;
    }

    // ==== RECOMMENDATIONS FLOW ====
    let usedLastSeed = false;

    // 1Ô∏è‚É£ Instant recommendations from lastFavSeed (new user just liked book)
    try {
      const rawSeed = sessionStorage.getItem('lastFavSeed');
      if (rawSeed) {
        const seedBook = JSON.parse(rawSeed);
        const recs = getSimilarFromCatalogue(seedBook);
        renderBecauseYouLiked(seedBook, recs);
        usedLastSeed = true;
        sessionStorage.removeItem('lastFavSeed');
      }
    } catch (e) {
      console.warn('[dash] lastFavSeed parse error', e);
    }

    // 2Ô∏è‚É£ If no lastFavSeed, old user ki one-shot load nundi rec (AI first)
    if (!usedLastSeed) {
      await oneShotLoadRecommendations(user.uid);
    }

    // 3Ô∏è‚É£ Live favourites listener (new fav add / remove) ‚Äî AI first
    setupFavoritesListener(user.uid, usedLastSeed);
  });
</script>

  <!-- optional: page scripts for books/search (if present in your project) -->
  <script src="dashboard-search.js" defer></script>
  <!--<script type="module" src="dashboard-search.js"></script>-->

<script src="popup.js" defer></script>
</body>
</html>
